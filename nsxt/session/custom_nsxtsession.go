/***************************************************************************
 * ========================================================================
 * Copyright 2022-2023 VMware, Inc.  All rights reserved. VMware Confidential
 * SPDX-License-Identifier: MPL-2.0
 * ========================================================================
 */

package nsxt

import (
	"bytes"
	"crypto/tls"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/http/httputil"
	"reflect"
	"strings"
	"time"
)

type Result struct {
	// Code should match the HTTP status code.
	Code int `json:"code"`

	// Message should contain a short description of the result of the requested
	// operation.
	Message *string `json:"message"`
}

// NsxtError represents an error resulting from a request to the Nsxt Manager
type Error struct {
	// nsxtresult holds the standard header (code and message) that is included in
	// responses from Nsxt.
	Result

	// verb is the HTTP verb (GET, POST, PUT, PATCH, or DELETE) that was
	// used in the request that resulted in the error.
	Verb string

	// url is the URL that was used in the request that resulted in the error.
	URL string

	// HttpStatusCode is the HTTP response status code (e.g., 200, 404, etc.).
	HTTPStatusCode int

	// err contains a descriptive error object for error cases other than HTTP
	// errors (i.e., non-2xx responses), such as socket errors or malformed JSON.
	err error
}

// HttpClient allows callers to inject their own implementations for the SDK to use.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// Error implements the error interface.
func (err Error) Error() string {
	var msg string

	if err.err != nil {
		msg = fmt.Sprintf("error: %v", err.err)
	} else if err.Message != nil {
		msg = fmt.Sprintf("HTTP code: %d; error from Nsxt: %s",
			err.HTTPStatusCode, *err.Message)
	} else {
		msg = fmt.Sprintf("HTTP code: %d.", err.HTTPStatusCode)
	}

	return fmt.Sprintf("Encountered an error on %s request to URL %s: %s",
		err.Verb, err.URL, msg)
}

// NsxtSession maintains a session to the specified Nsxt manager
type NsxtSession struct {
	// host specifies the hostname or IP address of the Nsxt Manager
	host string

	// username specifies the username with which we should authenticate with the Nsxt Manager.
	username string

	// password specifies the password with which we should authenticate with the Nsxt Manager.
	password string

	// auth token generated by Django, for use in token mode
	authToken string

	// insecure specifies whether we should perform strict certificate validation
	// for connections to the Nsxt Manager.
	insecure bool

	// timeout specifies time limit for API request. Default value set to 60 seconds
	timeout time.Duration

	// internal: session id for this session
	sessionid string

	// internal: csrfToken for this session
	csrfToken string

	// internal: referer field string to use in requests
	prefix string

	// internal: re-usable transport to enable connection reuse
	transport *http.Transport

	// internal: reusable client
	client HTTPClient

	// optional lazy authentication flag. This will trigger login when the first API call is made.
	// The authentication is not performed when the Session object is created.
	lazyAuthentication bool

	// optional maximum api retry count
	maxAPIRetries int

	// optional api retry interval in milliseconds
	apiRetryInterval int

	// retry status codes on which user wants to perform retry in case of failure
	retryStausCodes []int

	// TLS config for session
	tlsConfig *tls.Config

	// true in case of LDAP authentication, false in case of certificate based authentication
	securityContextNeeded bool

	// EnforcementPoint path for NSX policy
	enforcementPoint string
}

const DefaultAPITimeout = time.Duration(60 * time.Second) //nolint:unconvert
const DefaultMaxAPIRetries = 3
const DefaultAPIRetryInterval = 500

// NewNsxtSession initiates a session nsxt manager and returns it
func NewNsxtSession(host string, username string, tlsConfig *tls.Config, securityContextNeeded bool, options ...func(*NsxtSession) error) (*NsxtSession, error) { //nolint:revive
	if !flag.Parsed() {
		flag.Parse()
	}
	nsxtsess := &NsxtSession{
		host: host,
	}

	nsxtsess.securityContextNeeded = securityContextNeeded
	nsxtsess.username = username
	nsxtsess.sessionid = ""
	nsxtsess.csrfToken = ""
	nsxtsess.prefix = "https://" + nsxtsess.host + "/"
	// hard coding insecure to true
	// nsxtsess.insecure = true

	for _, option := range options {
		err := option(nsxtsess)
		if err != nil {
			return nsxtsess, err
		}
	}

	if nsxtsess.maxAPIRetries == 0 {
		nsxtsess.maxAPIRetries = DefaultMaxAPIRetries
	}

	if nsxtsess.apiRetryInterval == 0 {
		nsxtsess.apiRetryInterval = DefaultAPIRetryInterval
	}

	// set default timeout
	if nsxtsess.timeout == 0 {
		nsxtsess.timeout = DefaultAPITimeout
	}

	if tlsConfig != nil {
		nsxtsess.tlsConfig = tlsConfig
	} else {
		nsxtsess.tlsConfig = &tls.Config{InsecureSkipVerify: true}
	}

	if nsxtsess.client == nil {
		// create default transport object
		if nsxtsess.transport == nil {
			nsxtsess.transport = &http.Transport{
				// TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
				TLSClientConfig:     nsxtsess.tlsConfig,
				MaxIdleConns:        100,
				IdleConnTimeout:     90 * time.Second,
				MaxIdleConnsPerHost: 100,
			}
		}

		// attach transport object to client
		nsxtsess.client = &http.Client{
			Transport: nsxtsess.transport,
			Timeout:   nsxtsess.timeout,
		}
	}

	if !nsxtsess.lazyAuthentication {
		err := nsxtsess.initiateSession()
		return nsxtsess, err
	}
	return nsxtsess, nil
}

func (nsxtsess *NsxtSession) initiateSession() error {
	if nsxtsess.insecure {
		log.Printf("[WARNING] Strict certificate verification is *DISABLED*")
	}

	// initiate http session here
	// first set the csrf token
	var res interface{}

	// now login to get session_id, csrfToken
	cred := make(map[string]interface{})
	cred["username"] = nsxtsess.username
	cred["password"] = nsxtsess.password

	err := nsxtsess.Patch("login", cred, res)
	if err != nil {
		log.Printf("Error in Patch operation during NSX manager login. Error: %+v", err.Error())
	}
	return nil
}

// Post issues a POST request against the nsxtsess REST API.
func (nsxtsess *NsxtSession) Patch(uri string, payload interface{}, response interface{}, options ...APIOptionsParams) error {
	return nsxtsess.restRequestInterfaceResponse("PATCH", uri, payload, response, options...)
}

// Get issues a GET request against the nsxtsess REST API.
func (nsxtsess *NsxtSession) Get(uri string, response interface{}, options ...APIOptionsParams) error {
	return nsxtsess.restRequestInterfaceResponse("GET", uri, nil, response, options...)
}

// Post issues a POST request against the nsxtsess REST API.
func (nsxtsess *NsxtSession) Post(uri string, payload interface{}, response interface{}, options ...APIOptionsParams) error {
	return nsxtsess.restRequestInterfaceResponse("POST", uri, payload, response, options...)
}

// Put issues a PUT request against the nsxtsess REST API.
func (nsxtsess *NsxtSession) Put(uri string, payload interface{}, response interface{}, options ...APIOptionsParams) error {
	return nsxtsess.restRequestInterfaceResponse("PUT", uri, payload, response, options...)
}

// Delete issues a DELETE request against the nsxtsess REST API.
func (nsxtsess *NsxtSession) Delete(uri string, params ...interface{}) error {
	var payload, response interface{}
	if len(params) > 0 {
		payload = params[0]
		if len(params) == 2 {
			response = params[1]
		}
	}
	return nsxtsess.restRequestInterfaceResponse("DELETE", uri, payload, response)
}

// SetPassword - Use this for NewNsxtSession option argument for setting password
func SetPassword(password string) func(*NsxtSession) error {
	return func(sess *NsxtSession) error {
		return sess.setPassword(password)
	}
}

func (nsxtsess *NsxtSession) setPassword(password string) error {
	nsxtsess.password = password
	return nil
}

// SetAuthToken - Use this for NewNsxtSession option argument for setting authToken
func SetAuthToken(authToken string) func(*NsxtSession) error {
	return func(sess *NsxtSession) error {
		return sess.setAuthToken(authToken)
	}
}

func (nsxtsess *NsxtSession) setAuthToken(authToken string) error {
	nsxtsess.authToken = authToken
	return nil
}

// SetInsecure - Use this for NewNsxtSession option argument for allowing insecure connection to NsxtManager
func SetInsecure(insecure bool) func(*NsxtSession) error {
	return func(sess *NsxtSession) error {
		return sess.setInsecure(insecure)
	}
}

func (nsxtsess *NsxtSession) setInsecure(insecure bool) error {
	nsxtsess.insecure = insecure
	return nil
}

func (nsxtsess *NsxtSession) GetInsecure() bool {
	return nsxtsess.insecure
}

// SetEnforcementPoint- Use this to set enforcement point path for NSX policy
func SetEnforcementPoint(enforcementPoint string) func(*NsxtSession) error {
	return func(sess *NsxtSession) error {
		return sess.setEnforcementPoint(enforcementPoint)
	}
}

func (nsxtsess *NsxtSession) setEnforcementPoint(enforcementPoint string) error {
	nsxtsess.enforcementPoint = enforcementPoint
	return nil
}

func (nsxtsess *NsxtSession) GetEnforcementPoint() string {
	return nsxtsess.enforcementPoint
}

// SetTLSConfig - Use this for NewNsxtSession option argument for setting TLS in session
func SetTLSConfig(tlsconfig tls.Config) func(*NsxtSession) error {
	return func(sess *NsxtSession) error {
		return sess.setTLSConfig(tlsconfig)
	}
}

func (nsxtsess *NsxtSession) setTLSConfig(tlsconfig tls.Config) error {
	nsxtsess.tlsConfig = &tlsconfig
	return nil
}

// SetTransport - Use this for Newnsxtsession option argument for configuring http transport to enable connection
func SetTransport(transport *http.Transport) func(*NsxtSession) error {
	return func(sess *NsxtSession) error {
		return sess.setTransport(transport)
	}
}

func (nsxtsess *NsxtSession) setTransport(transport *http.Transport) error {
	if nsxtsess.client != nil {
		return errors.New("cannot set custom Transport for external clients")
	}
	nsxtsess.transport = transport
	return nil
}

// SetClient allows callers to inject their own HTTP client.
func SetClient(client HTTPClient) func(*NsxtSession) error {
	return func(sess *NsxtSession) error {
		return sess.setClient(client)
	}
}

func (nsxtsess *NsxtSession) setClient(client HTTPClient) error {
	if nsxtsess.transport != nil {
		return errors.New("cannot set custom client when transport is already set to http.Transport")
	}
	nsxtsess.client = client
	return nil
}

// SetTimeout
func SetTimeout(timeout time.Duration) func(*NsxtSession) error {
	return func(sess *NsxtSession) error {
		return sess.setTimeout(timeout)
	}
}

func (nsxtsess *NsxtSession) setTimeout(timeout time.Duration) error {
	nsxtsess.timeout = timeout
	return nil
}

// SetLazyAuthentication
func SetLazyAuthentication(lazyAuthentication bool) func(*NsxtSession) error {
	return func(sess *NsxtSession) error {
		return sess.setLazyAuthentication(lazyAuthentication)
	}
}

func (nsxtsess *NsxtSession) setLazyAuthentication(lazyAuthentication bool) error {
	nsxtsess.lazyAuthentication = lazyAuthentication
	return nil
}

func SetMaxAPIRetries(maxAPIRetries int) func(*NsxtSession) error {
	return func(sess *NsxtSession) error {
		return sess.setMaxAPIRetries(maxAPIRetries)
	}
}

func (nsxtsess *NsxtSession) setMaxAPIRetries(maxAPIRetries int) error {
	nsxtsess.maxAPIRetries = maxAPIRetries
	return nil
}

func SetAPIRetryInterval(apiRetryInterval int) func(*NsxtSession) error {
	return func(sess *NsxtSession) error {
		return sess.setAPIRetryInterval(apiRetryInterval)
	}
}

func (nsxtsess *NsxtSession) setAPIRetryInterval(apiRetryInterval int) error {
	nsxtsess.apiRetryInterval = apiRetryInterval
	return nil
}

func SetRetryStatusCodes(retryStatusCodes []int) func(*NsxtSession) error {
	return func(sess *NsxtSession) error {
		return sess.setRetryStatusCodes(retryStatusCodes)
	}
}

func (nsxtsess *NsxtSession) setRetryStatusCodes(retryStatusCodes []int) error {
	nsxtsess.retryStausCodes = retryStatusCodes
	return nil
}

func (nsxtsess *NsxtSession) newNsxtRequest(verb string, url string, payload io.Reader) (*http.Request, Error) {
	req, err := http.NewRequest(verb, url, payload)
	errorResult := Error{Verb: verb, URL: url}
	if err != nil {
		errorResult.err = fmt.Errorf("http.NewRequest failed: %v", err)
		return nil, errorResult
	}
	req.Header.Set("Content-Type", "application/json")
	// Set basic auth only when credentials are needed, because we need 'no Auth' in case of certificate based request
	if nsxtsess.securityContextNeeded {
		req.SetBasicAuth(nsxtsess.username, nsxtsess.password)
	}

	return req, errorResult
}

// RestRequest exports restRequest from the SDK
// Returns http.Response for accessing the whole http Response struct including headers and response body
func (nsxtsess *NsxtSession) RestRequest(verb string, uri string, payload interface{}, lastError error,
	retryNum ...int) (*http.Response, error) {
	return nsxtsess.restRequest(verb, uri, payload, nil)
}

// restRequest makes a REST request to the Nsxt Manager's REST API.
// Returns http.Response if successful
// Note: The caller of the function is responsible for doing resp.Body.Close()
func (nsxtsess *NsxtSession) restRequest(verb string, uri string, payload interface{}, lastError error,
	retryNum ...int) (*http.Response, error) {
	url := nsxtsess.prefix + uri

	// If optional retryNum arg is provided, then count which retry number this is
	maxAPIRetries := nsxtsess.maxAPIRetries

	var payloadIO io.Reader
	if payload != nil {
		jsonStr, err := json.Marshal(payload)
		if err != nil {
			return nil, Error{Verb: verb, URL: url, err: err}
		}
		payloadIO = bytes.NewBuffer(jsonStr)
	}

	req, errorResult := nsxtsess.newNsxtRequest(verb, url, payloadIO)
	log.Printf("[DEBUG] nsxt req: %v\n", req)
	if errorResult.err != nil {
		return nil, errorResult
	}

	retryReq := false
	resp, err := nsxtsess.client.Do(req)
	if err != nil {
		// retry until Manager status check limits.
		log.Printf("[ERROR] Client error for URI: %+v. Error: %+v", uri, err.Error())
		dump, dumpErr := httputil.DumpRequestOut(req, true)
		if dumpErr != nil {
			log.Printf("[ERROR] Error while dumping request. Still retrying.")
		}
		debug(dump, dumpErr)
		retryReq = true
	}

	if resp != nil && resp.StatusCode != 0 && retryReq {
		for i := 0; i < maxAPIRetries; i++ {
			log.Printf("[DEBUG] Retrying url %s; retry %d due to Status Code %d", url, i, resp.StatusCode)
			errorResult.HTTPStatusCode = resp.StatusCode
			// If response status code is failure code among user given codes, retry.
			if inSlice(resp.StatusCode, nsxtsess.retryStausCodes) {
				resp, err := nsxtsess.client.Do(req)
				if err == nil && resp != nil {
					break
				}
			}
			time.Sleep(time.Duration(nsxtsess.apiRetryInterval) * time.Millisecond)
		}
	}
	return resp, nil
}

// fetchBody fetches the response body from the http.Response returned from restRequest
func (nsxtsess *NsxtSession) fetchBody(verb, uri string, resp *http.Response) (result []byte, err error) {
	url := nsxtsess.prefix + uri
	var errorResult Error
	if resp != nil {
		errorResult = Error{HTTPStatusCode: resp.StatusCode, Verb: verb, URL: url}

		if resp.StatusCode == 204 {
			// no content in the response
			return result, nil
		}
		// It cannot be assumed that the error will always be from server side in response.
		// Error could be from HTTP client side which will not have body in response.
		// Need to change our API resp handling design if we want to handle client side errors separately.

		// Below block will take care for errors without body.
		if resp.Body == nil {
			log.Printf("[ERROR] Encountered client side error: %+v", resp)
			errorResult.Message = &resp.Status
			return result, errorResult
		}

		defer resp.Body.Close()
		result, err = ioutil.ReadAll(resp.Body)
		if err == nil {
			if resp.StatusCode < 200 || resp.StatusCode > 299 {
				mres, merr := convertNsxtResponseToMapInterface(result)
				log.Printf("[DEBUG] Error code %v parsed resp: %v err %v",
					resp.StatusCode, mres, merr)
				emsg := fmt.Sprintf("%v", mres)
				errorResult.Message = &emsg
			} else {
				return result, nil
			}
		} else {
			errmsg := fmt.Sprintf("Response body read failed: %v", err)
			errorResult.Message = &errmsg
			log.Printf("[ERROR] Error in reading uri %v %v", uri, err)
		}
	} else {
		errmsg := "Error occurred; no response from server"
		errorResult.Message = &errmsg
	}
	return result, errorResult
}

func convertNsxtResponseToMapInterface(resbytes []byte) (interface{}, error) {
	var result interface{}
	err := json.Unmarshal(resbytes, &result)
	return result, err
}

// NsxtCollectionResult for representing the collection type results from Nsxt
type CollectionResult struct {
	Count   int
	Results json.RawMessage
	Next    string
}

func debug(data []byte, err error) {
	if err == nil {
		log.Printf("\n\n[DEBUG] %s\n\n", data)
	} else {
		log.Printf("\n\n[DEBUG] %s\n\n", err)
	}
}

func (nsxtsess *NsxtSession) restRequestInterfaceResponse(verb string, url string,
	payload interface{}, response interface{}, options ...APIOptionsParams) error {
	if verb != "GET" && verb != "DELETE" {
		// remove all ids from the payload that were passed for policy path creation in resource
		m, ok := payload.(map[string]interface{})
		if !ok {
			return fmt.Errorf("want type map[string]interface{};  got %T", payload)
		}
		for k := range m {
			if strings.HasSuffix(k, "_id") && k != "virtual_machine_id" {
				delete(m, k)
			}
		}
	}

	if verb == "PATCH" || verb == "PUT" {
		m, ok := payload.(map[string]interface{})
		if !ok {
			return fmt.Errorf("want type map[string]interface{};  got %T", payload)
		}
		for k, v := range m {
			// if there is any incorrect capitals/lowercase in property name, map it to correct property in nsx. eg sharedWith in projectinfrashare
			if k == "sharedwith" {
				delete(m, k)
				k = "sharedWith"
				m[k] = v
			}
		}
	}

	opts, err := getOptions(options)
	if err != nil {
		return err
	}
	if len(opts.params) != 0 {
		url = updateURI(url, opts)
	}

	httpResponse, rerror := nsxtsess.restRequest(verb, url, payload, nil)
	if rerror != nil {
		return rerror
	}
	var res []byte
	if res, err = nsxtsess.fetchBody(verb, url, httpResponse); err != nil {
		return err
	}

	if len(res) != 0 && url != "login" {
		return json.Unmarshal(res, &response)
	}
	return nil
}

type APIOptions struct {
	name string
	// payload interface{}
	result interface{}
	params map[string]string
}

func SetName(name string) func(*APIOptions) error {
	return func(opts *APIOptions) error {
		return opts.setName(name)
	}
}

func (opts *APIOptions) setName(name string) error {
	opts.name = name
	return nil
}

func SetResult(result interface{}) func(*APIOptions) error {
	return func(opts *APIOptions) error {
		return opts.setResult(result)
	}
}

func (opts *APIOptions) setResult(result interface{}) error {
	opts.result = result
	return nil
}

func SetParams(params map[string]string) func(*APIOptions) error {
	return func(opts *APIOptions) error {
		return opts.setParams(params)
	}
}

func (opts *APIOptions) setParams(params map[string]string) error {
	opts.params = params
	return nil
}

type APIOptionsParams func(*APIOptions) error

func getOptions(options []APIOptionsParams) (*APIOptions, error) {
	opts := &APIOptions{}
	for _, opt := range options {
		err := opt(opts)
		if err != nil {
			return opts, err
		}
	}
	return opts, nil
}

func updateURI(uri string, opts *APIOptions) string {
	if strings.Contains(uri, "?") {
		uri += "&"
	} else {
		uri += "?"
	}
	for k, v := range opts.params {
		if k == "name" && opts.name != "" {
			continue
		} else {
			uri += k + "=" + v + "&"
		}
	}
	return uri
}

// GetObject performs GET and return object data
func (nsxtsess *NsxtSession) GetObject(path string, result interface{}) error {
	res, err := nsxtsess.GetCollectionRaw(path, result)
	if err != nil {
		return err
	}
	if res.Count == 0 {
		return errors.New("No object found with path : " + path)
	} else if res.Count > 1 {
		return errors.New("More than one objects found with path : " + path)
	}
	elems := make([]json.RawMessage, 1)
	err = json.Unmarshal(res.Results, &elems)
	if err != nil {
		return err
	}
	return json.Unmarshal(elems[0], &result)
}

// GetCollectionRaw issues a GET request and returns a NsxtCollectionResult with unmarshaled (raw) results section.
func (nsxtsess *NsxtSession) GetCollectionRaw(uri string, result interface{}) (CollectionResult, error) {
	var resultObj CollectionResult
	httpResponse, rerror := nsxtsess.restRequest("GET", uri, nil, nil, 0)
	if rerror != nil || httpResponse == nil {
		return resultObj, rerror
	}

	var res []byte
	var err error
	if res, err = nsxtsess.fetchBody("GET", uri, httpResponse); err != nil {
		return resultObj, err
	}

	err = json.Unmarshal(res, &result)

	return resultObj, err
}

func inSlice(val interface{}, slice interface{}) bool {
	sliceValue := reflect.ValueOf(slice)

	if sliceValue.Kind() != reflect.Slice {
		panic("inSlice() given a non-slice type")
	}

	for i := 0; i < sliceValue.Len(); i++ {
		item := sliceValue.Index(i).Interface()
		if reflect.DeepEqual(val, item) {
			return true
		}
	}
	return false
}
